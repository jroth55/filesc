#!/bin/bash

# Configuration
# =============

# Max file size in bytes (default: 2MB)
MAX_FILE_SIZE=$((1024 * 1024))

# Source directory (default: current directory)
SOURCE_DIR=&quot;${1:-.}&quot;

# Excluded file extensions
EXCLUDE_EXTENSIONS=(
    .env .log .gitignore .json .npmrc .prettierrc .eslintrc .babelrc 
    .pyc .pyo .pyd .class
    # Image files
    .jpg .jpeg .png .gif .bmp .tiff .webp .svg .ico .avif
)

# Excluded directories
EXCLUDE_DIRS=(
    .git .svn .vscode .idea node_modules venv .venv
    build dist out .next coverage
)

# Error handling function
die() {
    echo &quot;ERROR: $1&quot; &gt;&amp;2
    exit 1
}

# Platform detection for clipboard command
if command -v pbcopy &gt;/dev/null 2&gt;&amp;1; then
    CLIP_CMD=&quot;pbcopy&quot;
elif command -v xclip &gt;/dev/null 2&gt;&amp;1; then
    CLIP_CMD=&quot;xclip -selection clipboard&quot;
elif command -v clip &gt;/dev/null 2&gt;&amp;1; then
    CLIP_CMD=&quot;clip&quot;
else
    die &quot;No clipboard command found. Install pbcopy (macOS), xclip (Linux), or clip (Windows)&quot;
fi

# Check for required commands
command -v find &gt;/dev/null 2&gt;&amp;1 || die &quot;find command not available&quot;

# Helper functions
# ===============

# Check if a file has an excluded extension
has_excluded_extension() {
    local file=&quot;$1&quot;
    local ext=&quot;${file##*.}&quot;
    
    if [[ &quot;$ext&quot; != &quot;$file&quot; ]]; then
        ext=&quot;.$ext&quot;
        for excluded in &quot;${EXCLUDE_EXTENSIONS[@]}&quot;; do
            if [[ &quot;$ext&quot; == &quot;$excluded&quot; ]]; then
                echo &quot;Skipping (excluded extension): $file&quot; &gt;&amp;2
                return 0  # true, has excluded extension
            fi
        done
    fi
    return 1  # false, does not have excluded extension
}

# Check if a file is in an excluded directory
in_excluded_directory() {
    local file=&quot;$1&quot;
    
    for dir in &quot;${EXCLUDE_DIRS[@]}&quot;; do
        if [[ &quot;$file&quot; == *&quot;/$dir/&quot;* || &quot;$file&quot; == *&quot;/$dir&quot; ]]; then
            echo &quot;Skipping (excluded directory): $file&quot; &gt;&amp;2
            return 0  # true, in excluded directory
        fi
    done
    return 1  # false, not in excluded directory
}

# Check if a file is binary (faster method)
is_binary() {
    local file=&quot;$1&quot;
    
    # First check: look for null bytes as a quick binary indicator
    if grep -q -m1 -P &quot;[\x00]&quot; &quot;$file&quot; 2&gt;/dev/null; then
        echo &quot;Skipping (binary file): $file&quot; &gt;&amp;2
        return 0  # true, is binary
    fi
    
    # If file command is available, use it as a backup check
    if command -v file &gt;/dev/null 2&gt;&amp;1; then
        if file --mime &quot;$file&quot; 2&gt;/dev/null | grep -q &quot;charset=binary&quot;; then
            echo &quot;Skipping (binary file): $file&quot; &gt;&amp;2
            return 0  # true, is binary
        fi
    fi
    
    return 1  # false, not binary
}

# Check if a file is too large
is_too_large() {
    local file=&quot;$1&quot;
    local size
    
    if command -v stat &gt;/dev/null 2&gt;&amp;1; then
        # Try macOS format first, then Linux format
        size=$(stat -f%z &quot;$file&quot; 2&gt;/dev/null || stat --format=&quot;%s&quot; &quot;$file&quot; 2&gt;/dev/null)
    else
        # Fallback to ls if stat is not available
        size=$(ls -l &quot;$file&quot; 2&gt;/dev/null | awk &apos;{print $5}&apos;)
    fi
    
    # If we couldn&apos;t get the size, assume it&apos;s not too large
    if [[ -z &quot;$size&quot; ]]; then
        echo &quot;Warning: Could not determine size of $file, processing anyway&quot; &gt;&amp;2
        return 1
    fi
    
    if [[ $size -gt $MAX_FILE_SIZE ]]; then
        echo &quot;Skipping (file too large: ${size} bytes): $file&quot; &gt;&amp;2
        return 0  # true, is too large
    fi
    
    # Skip empty files
    if [[ $size -eq 0 ]]; then
        echo &quot;Skipping (empty file): $file&quot; &gt;&amp;2
        return 0  # true, is empty
    fi
    
    return 1  # false, not too large
}

# Function to get relative path
get_relative_path() {
    local full_path=&quot;$1&quot;
    local rel_path=&quot;${full_path#$SOURCE_DIR/}&quot;
    echo &quot;$rel_path&quot;
}

# Escape XML special characters
escape_xml() {
    sed &apos;s/&amp;/\&amp;amp;/g; s/&lt;/\&amp;lt;/g; s/&gt;/\&amp;gt;/g; s/&quot;/\&amp;quot;/g; s/&apos;\&apos;&apos;/\&amp;apos;/g&apos; &quot;$1&quot; 2&gt;/dev/null
}

# Main script
# ==========

# Ensure SOURCE_DIR is absolute path
if [[ ! &quot;$SOURCE_DIR&quot; = /* ]]; then
    SOURCE_DIR=&quot;$(pwd)/$SOURCE_DIR&quot;
fi

# Create a temporary file for the output to handle potential clipboard failures
TMP_FILE=$(mktemp)
trap &apos;rm -f &quot;$TMP_FILE&quot;&apos; EXIT

{
    echo &quot;&lt;files&gt;&quot;
    # Use -L to follow symlinks, check error code of find
    find -L &quot;$SOURCE_DIR&quot; \
        -not -path &quot;*/\.git/*&quot; \
        -not -path &quot;*/\.svn/*&quot; \
        -not -path &quot;*/\.vscode/*&quot; \
        -not -path &quot;*/\.idea/*&quot; \
        -not -path &quot;*/node_modules/*&quot; \
        -not -path &quot;*/venv/*&quot; \
        -not -path &quot;*/\.venv/*&quot; \
        -not -path &quot;*/build/*&quot; \
        -not -path &quot;*/dist/*&quot; \
        -not -path &quot;*/out/*&quot; \
        -not -path &quot;*/\.next/*&quot; \
        -not -path &quot;*/coverage/*&quot; \
        -type f -print0 2&gt;/dev/null | while IFS= read -r -d &apos;&apos; file; do
        # Skip files without read permission
        if [ ! -r &quot;$file&quot; ]; then
            echo &quot;Skipping (no read permission): $file&quot; &gt;&amp;2
            continue
        fi
        
        # Get relative path for display and output
        rel_path=$(get_relative_path &quot;$file&quot;)
        
        # Apply filters
        if in_excluded_directory &quot;$file&quot;; then
            continue
        fi
        
        if has_excluded_extension &quot;$file&quot;; then
            continue
        fi
        
        if is_binary &quot;$file&quot;; then
            continue
        fi
        
        if is_too_large &quot;$file&quot;; then
            continue
        fi
        
        # Process file
        echo &quot;Processing: $rel_path&quot; &gt;&amp;2
        echo &quot;&lt;file path=\&quot;$rel_path\&quot;&gt;&quot;
        
        # Capture error details if cat fails
        if ! escape_xml &quot;$file&quot;; then
            error=$?
            echo &quot;Unable to read file content: $rel_path (error code: $error)&quot;
            if [ ! -r &quot;$file&quot; ]; then
                echo &quot;Reason: File access permission denied&quot;
            elif [ ! -f &quot;$file&quot; ]; then
                echo &quot;Reason: Not a regular file&quot;
            else
                echo &quot;Reason: Unknown read error&quot;
            fi
        fi
        
        echo &quot;&lt;/file&gt;&quot;
    done
    
    if [ $? -ne 0 ]; then
        echo &quot;Warning: Find command may not have completed successfully&quot; &gt;&amp;2
    fi
    
    echo &quot;&lt;/files&gt;&quot;
} &gt; &quot;$TMP_FILE&quot;

# Use the appropriate clipboard command
if ! cat &quot;$TMP_FILE&quot; | eval &quot;$CLIP_CMD&quot;; then
    die &quot;Failed to copy to clipboard using $CLIP_CMD&quot;
fi

echo &quot;Done. Result copied to clipboard ($(wc -l &lt; &quot;$TMP_FILE&quot;) lines)&quot; &gt;&amp;2
